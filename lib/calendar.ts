import { format, addHours } from 'date-fns'

export interface CalendarEvent {
  id: string
  title: string
  description?: string
  location?: string
  startDate: Date
  endDate: Date
  customerName?: string
  customerPhone?: string
  serviceType?: string
  estimatedCost?: number
}

/**
 * Generate ICS calendar file content for appointments
 */
export function generateICSCalendar(events: CalendarEvent[], calendarName = 'Flynn AI Appointments'): string {
  const icsLines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//Flynn AI//Phone Integration//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:${calendarName}`,
    'X-WR-TIMEZONE:America/New_York',
    'X-WR-CALDESC:Appointments generated from phone calls by Flynn AI'
  ]

  // Add timezone information
  icsLines.push(
    'BEGIN:VTIMEZONE',
    'TZID:America/New_York',
    'X-LIC-LOCATION:America/New_York',
    'BEGIN:DAYLIGHT',
    'TZOFFSETFROM:-0500',
    'TZOFFSETTO:-0400',
    'TZNAME:EDT',
    'DTSTART:20070311T020000',
    'RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU',
    'END:DAYLIGHT',
    'BEGIN:STANDARD',
    'TZOFFSETFROM:-0400',
    'TZOFFSETTO:-0500',
    'TZNAME:EST',
    'DTSTART:20071104T020000',
    'RRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU',
    'END:STANDARD',
    'END:VTIMEZONE'
  )

  // Add events
  events.forEach(event => {
    const startDateTime = formatICSDate(event.startDate)
    const endDateTime = formatICSDate(event.endDate)
    const createdDateTime = formatICSDate(new Date())
    const uid = `${event.id}@flynnai.com`

    let description = event.description || ''
    if (event.customerName) description += `Customer: ${event.customerName}\n`
    if (event.customerPhone) description += `Phone: ${event.customerPhone}\n`
    if (event.serviceType) description += `Service: ${event.serviceType}\n`
    if (event.estimatedCost) description += `Estimated Cost: $${event.estimatedCost}\n`
    description += '\nGenerated by Flynn AI Phone Integration'

    icsLines.push(
      'BEGIN:VEVENT',
      `UID:${uid}`,
      `DTSTART;TZID=America/New_York:${startDateTime}`,
      `DTEND;TZID=America/New_York:${endDateTime}`,
      `DTSTAMP:${createdDateTime}`,
      `CREATED:${createdDateTime}`,
      `LAST-MODIFIED:${createdDateTime}`,
      `SUMMARY:${escapeICSText(event.title)}`,
      `DESCRIPTION:${escapeICSText(description)}`,
      event.location ? `LOCATION:${escapeICSText(event.location)}` : '',
      'STATUS:CONFIRMED',
      'SEQUENCE:0',
      'CLASS:PRIVATE',
      'X-MICROSOFT-CDO-IMPORTANCE:1',
      'END:VEVENT'
    )
  })

  icsLines.push('END:VCALENDAR')
  
  return icsLines.filter(line => line).join('\r\n')
}

/**
 * Format date for ICS format (YYYYMMDDTHHMMSS)
 */
function formatICSDate(date: Date): string {
  return format(date, "yyyyMMdd'T'HHmmss")
}

/**
 * Escape special characters for ICS text fields
 */
function escapeICSText(text: string): string {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/;/g, '\\;')
    .replace(/,/g, '\\,')
    .replace(/\r?\n/g, '\\n')
}

/**
 * Generate calendar event from job data
 */
export function jobToCalendarEvent(job: any): CalendarEvent {
  const startDate = job.scheduledDate ? new Date(job.scheduledDate) : new Date()
  
  // If we have scheduled time, parse and apply it
  if (job.scheduledTime && job.scheduledDate) {
    const [hours, minutes] = job.scheduledTime.split(':')
    startDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0)
  }

  // Default duration: 1 hour, or use estimatedDuration
  const durationHours = job.estimatedDuration ? job.estimatedDuration / 60 : 1
  const endDate = addHours(startDate, durationHours)

  return {
    id: job.id,
    title: job.title,
    description: job.description,
    location: job.address,
    startDate,
    endDate,
    customerName: job.customerName,
    customerPhone: job.customerPhone,
    serviceType: job.serviceType,
    estimatedCost: job.estimatedCost
  }
}

/**
 * Generate Google Calendar URL for an event
 */
export function generateGoogleCalendarURL(event: CalendarEvent): string {
  const params = new URLSearchParams({
    action: 'TEMPLATE',
    text: event.title,
    dates: `${formatGoogleDate(event.startDate)}/${formatGoogleDate(event.endDate)}`,
    details: event.description || '',
    location: event.location || '',
    trp: 'false'
  })

  return `https://calendar.google.com/calendar/render?${params.toString()}`
}

/**
 * Generate Outlook Calendar URL for an event
 */
export function generateOutlookCalendarURL(event: CalendarEvent): string {
  const params = new URLSearchParams({
    path: '/calendar/action/compose',
    rru: 'addevent',
    subject: event.title,
    startdt: event.startDate.toISOString(),
    enddt: event.endDate.toISOString(),
    body: event.description || '',
    location: event.location || ''
  })

  return `https://outlook.live.com/calendar/0/deeplink/compose?${params.toString()}`
}

/**
 * Format date for Google Calendar (YYYYMMDDTHHMMSSZ)
 */
function formatGoogleDate(date: Date): string {
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '')
}

/**
 * Create calendar reminder for appointment
 */
export async function createAppointmentReminder(
  jobId: string,
  userId: string,
  reminderMinutes = 60
): Promise<string> {
  try {
    const { prisma } = await import('./prisma')
    
    // Get job details
    const job = await prisma.job.findFirst({
      where: { id: jobId, userId }
    })

    if (!job || !job.scheduledDate) {
      throw new Error('Job not found or no scheduled date')
    }

    // Create reminder notification
    const reminderDate = new Date(job.scheduledDate.getTime() - (reminderMinutes * 60 * 1000))
    
    if (reminderDate <= new Date()) {
      throw new Error('Reminder time is in the past')
    }

    // In a real implementation, you would schedule this with a job queue
    // For now, we'll create a notification that can be picked up by a scheduler
    const reminderId = `reminder_${jobId}_${Date.now()}`
    
    console.log(`ðŸ“… Scheduled reminder for job ${job.title} at ${reminderDate.toISOString()}`)
    
    return reminderId
    
  } catch (error) {
    console.error('Failed to create appointment reminder:', error)
    throw error
  }
}

/**
 * Export jobs to ICS file
 */
export function exportJobsToICS(jobs: any[]): string {
  const events: CalendarEvent[] = jobs
    .filter(job => job.scheduledDate)
    .map(jobToCalendarEvent)

  return generateICSCalendar(events)
}